# 生命周期注解语法
    
    生命周期注解并不改变任何引用的生命周期的长短。
    与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，
    当指定了泛型生命周期后函数也能接受任何生命周期的引用。
    生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。

    生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（ ' ）开头，
    其名称通常全是小写，类似于 泛型其名称非常短。 'a 是大多数人默认使用的名称。
    生命周期参数注解位于引用的 & 之后，并有一个空格来 将引用类型与生命周期注解分隔开。

    我们有一个没有生命周期参数的 i32 的引用，一个有叫做 'a 的生命周期参数的 i32 的引用，
    和一个生命周期也是 'a 的 i32 的可变引用：
    1. &i32 // 引用 
    2. &'a i32 // 带有显式生命周期的引用 
    3. &'a mut i32 // 带有显式生命周期的可变引用

    单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数
    如何相互联系 的。例如如果函数有一个生命周期 'a 的 
    i32 的引用的参数 first 。还有另一个同样是生命周期 'a 的 i32 的引用的参数 second 。
    这两个生命周期注解意味着引用 first 和 second 必须与这泛型生命周 期存在得一样久。

# 函数签名中的生命周期注解

    就像泛型类型参数，泛型生命周期参数需要声明在函数名和参 数列表间的尖括号中。
    这里我们想要告诉 Rust 关于参数中的引用和返回值之间的限制是他们都必须拥有相同的生命周期
```rust
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x > y {
            x
        } else {
            y
        }
    }
```
    当在函数中使用生命周期注解时，这些注解出现在函数签名中，而不存在于函数体中的任何代码中。
    这是因为 Rust 能够分析函数中代码而不需要任何协助，
    不过当函数引用或被函数之外的代码引用时，让 Rust 自身分析出参数或返 回值的生命周期几乎是不可能的。
    这些生命周期在每次函数被调用时都可能不同。这也就是为什么我们需要手动标记 生命周期。
    
    当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。
    如果返回的引用 没有 指向 任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，
    它将会是一个悬垂引用， Rust 也不允许我们创建一个悬垂引用，
    因为它将会在函数结束 时离开作用域,这种情况是无法编译成功的。
    
    无法指定生命周期参数来改变悬垂引用，而且 Rust 也不允许我们创建一个悬垂引用。
    在这种情况，最好的 解决方案是返回一个有所有权的数据类型而不是一个引用，
    这样函数调用者就需要负责清理这个值了。

# 结构体定义中的生命周期注解

```rust
// ImportantExcerpt 它存放了一个字符串 slice，这是一个引用。类似于泛型参数类型，
// 必须在结构体名称后面的尖括号中声明泛型生命周期参数，以便在结构体定义中使用生命周期参数。
// 这个注解意味着 ImportantExcerpt 的实例不能比其 part 字段中的引用存在的更久
#[derive(Debug)]
struct ImportantExcerpt<'a>{
    part: &'a str,
}
```

    在编写了很多 Rust 代码后，Rust 团队发现在特定情况下 Rust 程序员们总是重复地
    编写一模一样的生命周期注解,这些场景是可预测的并且遵循几个明确的模式。
    接着 Rust 团队就把这些模式编码进了 Rust 编译器中，
    如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解。

    被编码进 Rust 引用分析的模式被称为 生命周期省略规则（lifetime elision rules）。
    这并不是需要程序员 遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，
    就无需明确指定生命周期。
    
    省略规则并不提供完整的推断：如果 Rust 在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话，
    它不 会猜测剩余引用的生命周期应该是什么。在这种情况，编译器会给出一个错误，这可以通过增加对应引用
    之间相联系 的生命周期注解来解决
    
    函数或方法的参数的生命周期被称为 输入生命周期（input lifetimes），
    而返回值的生命周期被称为输出生命 周期（output lifetimes）。

# 编译器三条规则

    编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生 命周期。
    如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。
    这些规 则适用于 fn 定义，以及 impl 块
    
    第一条规则是每一个是引用的参数都有它自己的生命周期参数。换句话说就是，
    有一个引用参数的函数有一个生命周 期参数： fn foo<'a>(x: &'a i32) ，
    有两个引用参数的函数有两个不同的生命周期参数， fn foo<'a, 'b>(x: &'a i32, y: &'b i32) ，
    依此类推。
    
    第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：
    fn foo<'a>(x: &'a i32) -> &'a i32 。

    第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self ，
    说明是个对象的方 法(method), 那么所有输出生命周期参数被赋予 self 的生命 周期。
    第三条规则使得方法更容易读写，因为只需更少的符号。

# 静态生命周期
    
    这里有一种特殊的生命周期值得讨论： 'static ，其生命周期能够存活于整个程序期间。
    所有的字符串字面值都拥有 'static 生命周期，我们也可以选择像下面这样标注出来：
```rust
    let s: &'static str = "I have a static lifetime.";
```
    这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。
    因此所有的字符串字面值都是 'static 的。

    你可能在错误信息的帮助文本中见过使用 'static 生命周期的建议，
    不过将引用指定为 'static 之前，思考 一下这个引用是否真的在整个程序的生命周期里都有效。
    你也许要考虑是否希望它存在得这么久，即使这是可能的。 大部分情况，
    代码中的问题是尝试创建一个悬垂引用或者可用的生命周期不匹配，
    请解决这些问题而不是指定一个 'static 的生命周期。

# 结合泛型类型参数、trait bounds 和生命周期
    
```rust
/*
ann 的类型是泛型 T ，它可以被放入任何实现了 where 从句中指定的 Display trait 的类 型。
这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 Display trait bound 是必须的。
因为生命周期也是泛型，所以生命周期参数 'a 和泛型类型参数 T 都位于函数名后的同一 尖括号列表中
 */
fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    }else{
        y
    }
}

```

    泛型类型参数、trait 和 trait bounds 以及泛型生命周期类型，你已 经准备好编写既不重复又能适用于多种场景的代码了。
    泛型类型参数意味着代码可以适用于不同的类型。trait 和 trait bounds 保证了即使类型是泛型的，这些类型也会拥有所需要的行为。
    由生命周期注解所指定的引用生命周期 之间的关系保证了这些灵活多变的代码不会出现悬垂引用。
    而所有的这一切发生在编译时所以不会影响运行时效率！
